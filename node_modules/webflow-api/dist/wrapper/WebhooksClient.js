"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const Client_1 = require("../api/resources/webhooks/client/Client");
const crypto_1 = __importDefault(require("crypto"));
class Client extends Client_1.Webhooks {
    constructor(_options) {
        super(_options);
    }
    /**
     * Verify that the signature on the webhook message is from Webflow
     * @link https://developers.webflow.com/data/docs/working-with-webhooks#validating-request-signatures
     *
     * @param {Webhooks.RequestSignatureDetails.headers} requestSignatureDetails - details of the incoming webhook request
     * @example
     *     function incomingWebhookRouteHandler(req, res) {
     *       const headers = req.headers;
     *       const body = JSON.stringify(req.body);
     *       const secret = getWebhookSecret(WEBHOOK_ID);
     *       const isAuthenticated = await client.webhooks.verifySignature({ headers, body, secret });
     *
     *       if (isAuthenticated) {
     *           // Process the webhook
     *       } else {
     *           // Alert the user that the webhook is not authenticated
     *       }
     *       res.sendStatus(200);
     *     }
     *
     */
    verifySignature(_a) {
        return __awaiter(this, arguments, void 0, function* ({ headers, body, secret }) {
            // Creates a HMAC signature following directions from https://developers.webflow.com/data/docs/working-with-webhooks#steps-to-validate-the-request-signature
            const createHmac = (signingSecret, message) => __awaiter(this, void 0, void 0, function* () {
                const encoder = new TextEncoder();
                // Encode the signingSecret key
                const key = yield crypto_1.default.subtle.importKey("raw", encoder.encode(signingSecret), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
                // Encode the message and compute HMAC signature
                const signature = yield crypto_1.default.subtle.sign("HMAC", key, encoder.encode(message));
                // Convert signature to hex string
                return Array.from(new Uint8Array(signature))
                    .map((b) => b.toString(16).padStart(2, "0"))
                    .join("");
            });
            const message = `${headers["x-webflow-timestamp"]}:${body}`;
            const generatedSignature = yield createHmac(secret, message);
            return headers["x-webflow-signature"] === generatedSignature;
        });
    }
}
exports.Client = Client;
