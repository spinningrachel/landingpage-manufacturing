"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const Client_1 = require("../api/resources/assets/client/Client");
const crypto_1 = __importDefault(require("crypto"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const form_data_1 = __importDefault(require("form-data"));
// Utilities class for Assets to add custom helper methods to assist in managing Webflow Assets
class Client extends Client_1.Assets {
    constructor(_options) {
        super(_options);
        this._options = _options;
    }
    _getBufferFromUrl(url) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield (0, node_fetch_1.default)(url);
                if (!response.ok) {
                    throw new Error(`Failed to fetch asset from URL: ${url}. Status: ${response.status} ${response.statusText}`);
                }
                return yield response.arrayBuffer();
            }
            catch (error) {
                throw new Error(`Error occurred while fetching asset from URL: ${url}. ${error.message}`);
            }
        });
    }
    /**
     * Create the Asset metadata in Webflow, and immediately upload it to the S3 bucket on behalf of the user to simplify the 2-step process
     *
     * @param siteId
     * @param request
     * @param requestOptions
     * @returns
     */
    createAndUpload(siteId, request, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            /** 1. Generate the hash */
            const { file, fileName, parentFolder } = request;
            let tempBuffer;
            if (typeof file === 'string') {
                const arrBuffer = yield this._getBufferFromUrl(file);
                tempBuffer = Buffer.from(arrBuffer);
            }
            else if (file instanceof ArrayBuffer) {
                tempBuffer = Buffer.from(file);
            }
            if (!Buffer.isBuffer(tempBuffer)) {
                throw new Error('Invalid Buffer: Cannot create a buffer from the provided file');
            }
            const hash = crypto_1.default.createHash("md5").update(tempBuffer).digest("hex");
            const wfUploadRequest = Object.assign({ fileName, fileHash: hash }, (parentFolder && { parentFolder }));
            /** 2. Create the Asset Metadata in Webflow */
            let wfUploadedAsset;
            try {
                wfUploadedAsset = yield this.create(siteId, wfUploadRequest, requestOptions);
                if (!wfUploadedAsset || !wfUploadedAsset.uploadDetails) {
                    throw new Error("Failed to create Asset metadata in Webflow, no S3 headers returned");
                }
            }
            catch (error) {
                throw new Error(`Failed to create Asset metadata in Webflow: ${error.message}`);
            }
            /** 3. Create FormData with S3 bucket signature */
            const wfUploadDetails = wfUploadedAsset.uploadDetails;
            const uploadUrl = wfUploadedAsset.uploadUrl;
            // Temp workaround since headers from response are being camelCased and we need them to be exact when sending to S3
            const headerMappings = {
                'xAmzAlgorithm': 'X-Amz-Algorithm',
                'xAmzDate': 'X-Amz-Date',
                'xAmzCredential': 'X-Amz-Credential',
                'xAmzSignature': 'X-Amz-Signature',
                'successActionStatus': 'success_action_status',
                'contentType': 'Content-Type',
                'cacheControl': 'Cache-Control',
            };
            const transformedUploadHeaders = Object.keys(wfUploadDetails).reduce((acc, key) => {
                const mappedKey = headerMappings[key] || key;
                acc[mappedKey] = wfUploadDetails[key];
                return acc;
            }, {});
            const formDataToUpload = new form_data_1.default();
            Object.keys(transformedUploadHeaders).forEach((key) => {
                formDataToUpload.append(key, transformedUploadHeaders[key]);
            });
            formDataToUpload.append("file", tempBuffer, {
                filename: fileName,
                contentType: wfUploadedAsset.contentType || "application/octet-stream",
            });
            /** 4. Upload to S3  */
            try {
                const response = yield (0, node_fetch_1.default)(uploadUrl, {
                    method: 'POST',
                    body: formDataToUpload,
                    headers: Object.assign({}, formDataToUpload.getHeaders()),
                });
                if (!response.ok) {
                    const errorText = yield response.text();
                    throw new Error(`Failed to upload to S3. Status: ${response.status}, Response: ${errorText}`);
                }
            }
            catch (error) {
                throw new Error(`Error occurred during S3 upload: ${error.message}`);
            }
            return wfUploadedAsset;
        });
    }
}
exports.Client = Client;
